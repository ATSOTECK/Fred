#include <QString>
#include <QList>
#include <math.h>

static const float MAX_MOUSE_VALUE = 350.0;
static const float MIN_MOUSE_VALUE = -MAX_MOUSE_VALUE;

static const float MAX_MOTOR_VALUE = 179.0;
static const float ZERO_MOTOR_VALUE = 90;
static const float MIN_MOTOR_VALUE = 1.0;


static const int NMOTORS = 8;

#include <QtCore/qmath.h>

/*
Data received from 3d mouse.
range: -350 : +350
*/
struct MouseData
{
    int tx, ty, tz, rx, ry, rz;
};

/*
State of all 8 motors.
Each float represents the thrust of a single motor and varies from -1 to 1

The enumeration of the motors is as follows:

    0 : 3 => upper motors
    4 : 7 => lower motors

    0 => upper left front
    1 => upper right front
    2 => upper left back
    3 => upper right back

    4 => lower left front
    5 => lower right front
    6 => lower left back
    7 => lower right back

For those of you who don't know C/C++ very well, a union is a struct where all members share the same
location in memory, hence the array "data" and the variables m0 though m7 in "values" are the same variables
changing one will effect the other. This is just a convience.
*/
union MotorState
{
    float data[NMOTORS];

    struct
    {
        float m0, m1, m2, m3, m4, m5, m6, m7;
    } values;

    //returns a motor data generated by multiplying data through by a constant.
    const MotorState scale(float f) const
    {
        MotorState result;

        for (int i = 0; i < NMOTORS; i ++)
        {
            result.data[i] = this->data[i] * f;
        }

        return result;
    }

    //returns the sum of this MotorState and another MotorState
    const MotorState operator + (const MotorState& other) const
    {
        MotorState result;

        for (int i = 0; i < 8; i ++)
        {
            result.data[i] = this->data[i] + other.data[i];
        }

        return result;
    }

    //scale all values such that the largest value is <= 1
    //leaves state unchanged if no value is > 1
    void normalize()
    {
        float max = 0;

        float magnitude;

        for (int i = 0; i < NMOTORS; i ++)
        {
            magnitude = fabs(data[i]);

            if (magnitude > max)
            {
                max = magnitude;
            }
        }

        if (max > 1)
        {
            for (int i = 0; i < NMOTORS; i ++)
            {
                data[i] /= max;
            }
        }
    }

    const MotorState convertToAdruinoFormat()
    {
        MotorState result;

        for (int i = 0; i < NMOTORS; i ++)
        {
            result.data[i] = this->data[i] * (MAX_MOTOR_VALUE/2) + ZERO_MOTOR_VALUE;
        }

        return result;
    }
};


/*s
These MotorState objects each represent the state of the motors needed to acheive the given action.
Refer to the declaration of MotorState for the enumeration of the different motors.
The signs and general magnitudes of these values are correct, but may require tweaking
to compensate for irregularities in the strength/positioning of individual motors.
*/
static const MotorState moveX = {-1,  1,  1,  -1,  0, 0, 0, 0};
static const MotorState moveY = {0, 0, 0, 0, 1,  1,  1,  1};
static const MotorState moveZ = {1,  1,  1,  1,  0, 0, 0, 0};
static const MotorState turnX = {0, 0, 0, 0, -1,  -1,  1,  1};
static const MotorState turnY = {1,  -1,  1,  -1,  0, 0, 0, 0};
static const MotorState turnZ = {0, 0, 0, 0, -1,  1,  -1,  1};
//parses an HTTP string and createsa MouseData object
MouseData parseHTTPtoMouse(QString http)
{
    MouseData result = {0};

    http = http.toLower().remove(0,1);

    QStringList tokens = http.split("&");
    
    int MouseData::*var;

    foreach (QString token, tokens)
    {
        if (token.length() == 0)
        {
            continue;
        }

        QString prefix = token.left(2);
    	
        if (prefix == "tx")
		{
			var = &MouseData::tx;
		}
        else if (prefix == "ty")
		{
			var = &MouseData::ty;
		}
        else if (prefix == "tz")
        {
			var = &MouseData::tz;
		}
        else if (prefix == "rx")
		{
			var = &MouseData::rx;
		}
        else if (prefix == "ry")
		{
			var = &MouseData::ry;
		}
        else if (prefix == "rz")
		{
			var = &MouseData::rz;
		}
		else
		{
            qDebug() << "Error: unknown http token: " << token << " prefix: " << prefix;
		}
    	
        token = token.remove(0,3);
    	
        (result.*var) = token.toFloat();
    }
        
    return result;
}


//convert motor data to an HTTP-encoded string.
QString formatMotorToHTTP(const MotorState& dat)
{
    QString result;

	for (int i = 0; i < NMOTORS; i ++)
	{
        result = result.append(i ? "&" : "?")
                .append("m")
                .append(QString().setNum(i))
                .append("=")
                .append(QString().setNum((int)qFloor(dat.data[i])));
    }

    return result;
}

/*
Convert information from mouse to the thrust needed for each motor
by summing all desired actions and normalizing.
*/
MotorState convertMouseToMotor(const MouseData& dat)
{
	//each of these represents what the state of the motors would be if the given command was issued.
    MotorState requestedmoveX = moveX.scale(dat.tx/MAX_MOUSE_VALUE);
    MotorState requestedmoveY = moveY.scale(dat.ty/MAX_MOUSE_VALUE);
    MotorState requestedmoveZ = moveZ.scale(dat.tz/MAX_MOUSE_VALUE);

    MotorState requestedTurnX = turnX.scale(dat.rx/MAX_MOUSE_VALUE);
    MotorState requestedTurnY = turnY.scale(dat.ry/MAX_MOUSE_VALUE);
    MotorState requestedTurnZ = turnZ.scale(dat.rz/MAX_MOUSE_VALUE);

	MotorState result = requestedmoveX
						+ requestedmoveY
						+ requestedmoveZ
						+ requestedTurnX
						+ requestedTurnY
						+ requestedTurnZ;
	
	//normalize result such that no motor is told to fire at > 100%

    result.normalize();

    result = result.convertToAdruinoFormat();

	return result;
}

//convert mouse data to motor data, then to HTTP.
QString convertMouseHTTPtoMotorHTTP(QString mouseHttp)
{
    return formatMotorToHTTP( convertMouseToMotor( parseHTTPtoMouse ( mouseHttp ) ) ).append("#");
}


